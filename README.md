Dans ce TP, l’objectif était de créer une API REST pour gérer une bibliothèque. On devait pouvoir gérer les auteurs et les livres, avec toutes les opérations classiques : créer, lire, mettre à jour et supprimer. Certains endpoints, comme POST, PUT et DELETE, devaient être sécurisés par une clé API, tandis que les GET étaient publics. Pour cela, on a utilisé Spring Boot avec Java 25, Spring Data JPA pour gérer la base de données, et MySQL pour stocker les informations. J’ai également ajouté Springdoc OpenAPI pour pouvoir visualiser et tester l’API dans Swagger.

La première étape a été de configurer le projet dans IntelliJ avec les dépendances nécessaires : Spring Web, Spring Data JPA, MySQL Driver et Springdoc OpenAPI. Ensuite, j’ai configuré la connexion à la base MySQL dans le fichier application.properties, en précisant l’URL de la base, le nom d’utilisateur, le mot de passe, le dialecte Hibernate, et la clé API à utiliser pour sécuriser certaines routes.

On a ensuite créé les entités Author et Book. Pour Author, il y avait les champs id, firstName, lastName et birthYear. Pour Book, il y avait id, title, isbn, year, category et une relation ManyToOne avec Author. L’ISBN était unique pour éviter les doublons. Les repositories étaient des interfaces simples qui étendaient JpaRepository, ce qui permettait de gérer facilement les opérations CRUD sans écrire de SQL.

Les controllers ont été créés pour exposer les endpoints. Par exemple, AuthorController contenait les méthodes GET pour récupérer tous les auteurs ou un auteur par ID, et POST pour créer un auteur, en vérifiant que la clé API fournie dans le header était correcte. GET restait public, mais POST, PUT et DELETE nécessitaient le header X-API-KEY. Pour les livres, j’ai ajouté des filtres sur les endpoints GET afin de pouvoir chercher par titre, auteur, catégorie ou année, et de gérer la pagination et le tri.

Pour tester l’API, on a utilisé Postman. on a d’abord testé les GET pour voir la liste des auteurs et livres, puis les POST avec la clé API pour ajouter de nouveaux auteurs et livres. J’ai appris qu’il fallait faire attention aux valeurs uniques comme l’ISBN, sinon MySQL renvoie une erreur de violation de contrainte. Les DELETE ont été testés de la même manière, en incluant la clé API dans les headers. on a  également utilisé Swagger pour visualiser et tester rapidement tous les endpoints dans le navigateur.
